#ifndef POPULATION_H
#define POPULATION_H

#include "Country.h"
#include "LocalSearch.h"
#include "Split.h"

typedef std::vector <Country*> SubPopulation ;

class Population
{
   private:

   Params * params ;							// Problem parameters
   Split * split;								// Split algorithm
   LocalSearch * localSearch;					// Local search structure
   std::list <bool> listFeasibilityLoad ;		// Load feasibility of the last 100 individuals generated by LS
   std::list <bool> listFeasibilityDuration ;	// Duration feasibility of the last 100 individuals generated by LS
   Country bestSolutionRestart;              // Best solution found during the current restart of the algorthm
   Country bestSolutionOverall;              // Best solution found during the complete execution of the algorithm

   public:

   SubPopulation feasibleSubpopulation;			// Feasible subpopulation, kept ordered by increasing penalized cost
   SubPopulation infeasibleSubpopulation;		// Infeasible subpopulation, kept ordered by increasing penalized cost
   std::vector<std::pair<clock_t, double>> searchProgress; // Keeps tracks of the time stamps of successive best solutions
   clock_t bestfoundclock;
   std::vector<std::pair<double, double>> performanceProgess; // to keep the performance of algorithm in different stages of search
   double perfStages [10] = {1, 2, 5, 10, 15, 20, 30, 50, 75, 100}; // different stages to save the performance
	int perfPointer = 0;

   // Removes the worst country in terms of biased fitness
   void removeWorstBiasedFitness(SubPopulation & subpop);

   // Creates an initial population of individuals
   void generatePopulation();

   // Add an country in the population (survivor selection is automatically triggered whenever the population reaches its maximum size)
   // Returns TRUE if a new best solution of the run has been found
   bool addCountry (const Country * cntry, bool updateFeasible);

   // Evaluates the biased fitness of all individuals in the population
   void updateBiasedFitnesses(SubPopulation & pop);

   // Cleans all solutions and generates a new initial population (only used when running HGS until a time limit, in which case the algorithm restarts until the time limit is reached)
   void restart();

   // Adaptation of the penalty parameters
   void managePenalties();

   // Select an individal by binary tournament
   Country * getBinaryTournament();

   // Select a random country from population
   Country * getRandomCountry();

   // Accesses the best feasible country
   Country * getBestFeasible();

   // Accesses the best infeasible country
   Country * getBestInfeasible();

   // Accesses the best found solution at all time
   Country * getBestFound();

   // Prints population state
   void printState(int nbIter, int nbIterNoImprovement);

   // Returns the average diversity value among the 50% best individuals in the subpopulation
   double getDiversity(const SubPopulation & pop);

   // Returns the average solution value among the 50% best individuals in the subpopulation
   double getAverageCost(const SubPopulation & pop);

   // Overwrites a solution written in a file if the current solution is better
   void exportBKS(std::string fileName);

   // Exports in a file the history of solution improvements
   void exportSearchProgress(std::string fileName, std::string instanceName, int seedRNG, int prevtime);

   // Exports in a file the performance of algorithm in different stages of search
   void exportPerformanceProgress(std::string fileName);

   // Constructor
   Population(Params * params, Split * split, LocalSearch * localSearch);

   // Empty Popluation class
   Population();

   // Destructor
   ~Population();
};

#endif
